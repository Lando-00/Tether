from __future__ import annotations
from typing import Protocol, runtime_checkable, Any, AsyncIterator, Tuple, Optional, Dict, Callable, List
from llm_service.protocol.core.types import TokenDelta

@runtime_checkable
class Logger(Protocol):
    def info(self, msg: str, *args) -> None: ...
    def warning(self, msg: str, *args) -> None: ...
    def error(self, msg: str, *args) -> None: ...
    def exception(self, msg: str, *args) -> None: ...
    def debug(self, msg: str, *args) -> None: ...

@runtime_checkable
class ExecutionStrategy(Protocol):
    def execute_with_timeout(self, func: Callable, args: tuple, kwargs: dict, timeout: int) -> Any: ...
    def cleanup(self) -> None: ...

@runtime_checkable
class ConfigProvider(Protocol):
    def get_max_token_buffer_size(self) -> int: ...
    def get_tool_execution_timeout(self) -> int: ...
    def get_max_tool_loops(self) -> int: ...
    def get_tool_prefix(self) -> str: ...
    def get_async_timeout(self) -> int: ...
    def get_thread_pool_workers(self) -> int: ...

@runtime_checkable
class TokenSource(Protocol):
    async def stream(self) -> AsyncIterator["TokenDelta"]:
        ...

@runtime_checkable
class ToolCallStrategy(Protocol):
    def feed(self, token: str) -> Tuple[str, Optional[str]]:
        """
        Returns one of:
          ("undecided", None)
          ("prose", text)
          ("call_started", tool_name)         # without "__tool_" prefix
          ("call_complete", raw_arg_text)
        """
        ...

@runtime_checkable
class ArgsParser(Protocol):
    def parse(self, raw: str) -> Dict[str, Any]:
        ...

@runtime_checkable
class ToolExecutor(Protocol):
    def execute(self, published_name: str, args: Dict[str, Any]) -> Any:
        """
        published_name: e.g., "__tool_get_current_time"
        """
        ...

@runtime_checkable
class HistoryWriter(Protocol):
    def add_user(self, session_id: str, content: str) -> None: ...
    def add_assistant_text(self, session_id: str, content: str) -> None: ...
    def add_assistant_toolcall(self, history: list, tool_id: str, pub_name: str, args: Dict[str, Any]) -> None: ...
    def add_tool_result(self, history: list, tool_id: str, pub_name: str, result: Any) -> None: ...
    def get_history(self, session_id: str) -> list: ...
    def ensure_system_prompt(self, history: list, tools: list[dict]) -> None: ...

@runtime_checkable
class EventEmitter(Protocol):
    def token(self, text: str) -> bytes: ...
    def hidden_thought(self, text: str, phase: str) -> bytes: ...
    def tool_start(self, tc_id: str, published_name: str) -> bytes: ...
    def tool_end(self, tc_id: str, published_name: str, result: Any) -> bytes: ...
    def done(self) -> bytes: ...
